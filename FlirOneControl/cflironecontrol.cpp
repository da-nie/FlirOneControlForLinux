//****************************************************************************************************
//подключаемые библиотеки
//****************************************************************************************************
#include "cflironecontrol.h"
#include "craiicmutex.h"
#include "system.h"
#include "clog.h"

//****************************************************************************************************
//глобальные переменные
//****************************************************************************************************

//****************************************************************************************************
//константы
//****************************************************************************************************

//****************************************************************************************************
//макроопределения
//****************************************************************************************************

//****************************************************************************************************
//прототипы функций
//****************************************************************************************************
void* ThreadFunction(void *ptr);//поток обработки

//****************************************************************************************************
//конструктор и деструктор
//****************************************************************************************************

//----------------------------------------------------------------------------------------------------
//конструктор
//----------------------------------------------------------------------------------------------------
CFlirOneControl::CFlirOneControl(void)
{
 ReceiveBuffer_Ptr.reset(new uint8_t[RECEIVE_BUFFER_SIZE]);
 Delay=1;
 //запускаем поток обработки
 StartThread();
}
//----------------------------------------------------------------------------------------------------
//деструктор
//----------------------------------------------------------------------------------------------------
CFlirOneControl::~CFlirOneControl()
{
 StopThread();
 Close();
}

//****************************************************************************************************
//закрытые функции
//****************************************************************************************************

//---------------------------------------------------------------------------
//запустить поток
//---------------------------------------------------------------------------
void CFlirOneControl::StartThread(void)
{
 StopThread();
 //запускаем поток обработки
 sProtected.ExitThread=false;
 cThread_Processing.Create(ThreadFunction,this);
}
//---------------------------------------------------------------------------
//остановить поток
//---------------------------------------------------------------------------
void CFlirOneControl::StopThread(void)
{
 {
  CRAIICMutex cRAIICMutex(&sProtected.cMutex);
  {
   sProtected.ExitThread=true;
  }
 }
 cThread_Processing.Join();
}

//****************************************************************************************************
//открытые функции
//****************************************************************************************************

//----------------------------------------------------------------------------------------------------
//подключиться к устройству
//----------------------------------------------------------------------------------------------------
bool CFlirOneControl::Open(void)
{
 Close();
 return(cFlirOneDriver.Open());
}
//----------------------------------------------------------------------------------------------------
//отключиться от устройства
//----------------------------------------------------------------------------------------------------
void CFlirOneControl::Close(void)
{
 cFlirOneDriver.Close();
}
//----------------------------------------------------------------------------------------------------
//обработка
//----------------------------------------------------------------------------------------------------
bool CFlirOneControl::Processing(void)
{
 {
  CRAIICMutex cRAIICMutex(&sProtected.cMutex);
  {
   if (sProtected.ExitThread==true) return(false);//требуется завершение потока
  }
 }
 PauseInMs(1);
 Delay=1; 
 uint32_t size=RECEIVE_BUFFER_SIZE;
 if (cFlirOneDriver.ReadStream(ReceiveBuffer_Ptr.get(),size)==false)
 {
  Open();
  Delay=1000;
 }
 else
 {
  CRAIICMutex cRAIICMutex(&sProtected.cMutex);
  {
   if (size>0)
   {
    sProtected.cFlirOneReceiver.CreateImage(ReceiveBuffer_Ptr.get(),size);
   }
  }
 }
 return(true);
}

//----------------------------------------------------------------------------------------------------
//загрузить карту перекодировки изображения
//----------------------------------------------------------------------------------------------------
bool CFlirOneControl::LoadColorMap(const std::string &filename)
{
 CRAIICMutex cRAIICMutex(&sProtected.cMutex);
 {
  return(sProtected.cFlirOneReceiver.LoadColorMap(filename));
 }
}

//----------------------------------------------------------------------------------------------------
//скопировать раскрашенное изображение в буфер
//----------------------------------------------------------------------------------------------------
bool CFlirOneControl::CopyColorImage(std::vector<uint32_t> &image,uint32_t &index)
{
 CRAIICMutex cRAIICMutex(&sProtected.cMutex);
 {
  return(sProtected.cFlirOneReceiver.CopyColorImage(image,index));
 }
}
//----------------------------------------------------------------------------------------------------
//скопировать тепловое изображение в буфер
//----------------------------------------------------------------------------------------------------
bool CFlirOneControl::CopyThermalImage(std::vector<uint16_t> &image,uint32_t &index)
{
 CRAIICMutex cRAIICMutex(&sProtected.cMutex);
 {
  return(sProtected.cFlirOneReceiver.CopyThermalImage(image,index));
 }
}
//----------------------------------------------------------------------------------------------------
//скопировать изображение с видеокамеры в буфер
//----------------------------------------------------------------------------------------------------
bool CFlirOneControl::CopyVideoImage(std::vector<uint32_t> &image,uint32_t &index)
{
 CRAIICMutex cRAIICMutex(&sProtected.cMutex);
 {
  return(sProtected.cFlirOneReceiver.CopyVideoImage(image,index));
 }
}
//----------------------------------------------------------------------------------------------------
//скопировать палитру
//----------------------------------------------------------------------------------------------------
bool CFlirOneControl::CopyColorMap(uint8_t R[CFlirOneReceiver::COLOR_MAP_UNIT],uint8_t G[CFlirOneReceiver::COLOR_MAP_UNIT],uint8_t B[CFlirOneReceiver::COLOR_MAP_UNIT],uint32_t size)
{
 CRAIICMutex cRAIICMutex(&sProtected.cMutex);
 {
  return(sProtected.cFlirOneReceiver.CopyColorMap(R,G,B,size));
 }
}
//----------------------------------------------------------------------------------------------------
//показывать ли видео
//----------------------------------------------------------------------------------------------------
void CFlirOneControl::SetShowVideo(bool state)
{
 CRAIICMutex cRAIICMutex(&sProtected.cMutex);
 {
  sProtected.cFlirOneReceiver.SetShowVideo(state);
 }
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//----------------------------------------------------------------------------------------------------
//поток обработки
//----------------------------------------------------------------------------------------------------
void* ThreadFunction(void *ptr)
{
 CFlirOneControl *cFlirOneControl_Ptr=reinterpret_cast<CFlirOneControl *>(ptr);
 while(1)
 {
  if (cFlirOneControl_Ptr->Processing()==false) break;
 }
 return(NULL);
}
